TITLE The Concise Python Tutorial, part 5: Functions
NAV The Concise Python Tutorial, part 5: Functions
TEMPLATE DEFAULT
MARKDOWN
DESC We're finally getting to functions! Functions are a central concept to everything in programming.

This time we're getting *real*, and I mean *real* real. You're going to learn how to *make your own functions*. It was fun to see how far we could get without this, but it's an utterly essential aspect of programming. In fact, the projects for chapters 3 and 4 could probably have been improved a lot by using functions.

# Function jargon

First all, I've been saying the word already but to lay it out explicitly, a *function* is a part of a program that can be used ("called", or "invoked") from other parts of the program, as many times as you want. You can think of it as a mini-program. Built-in (predefined) functions we've already worked with include `print`, `input`, `int`, `str`, `float`, `len`, and a bunch more.

Any time you call a function, you put parentheses after it. The parentheses mean that you want the function to be called and replaced with its return value. The values put inside the parentheses are the **arguments** or **parameters** that you want the function to operate with.

That concept - a function taking an argument - is part of what makes functions so powerful. They allow you to write code that can be reused (without copy-pasting it) on a new piece of data. Concrete examples will make this a lot clearer later on.

So here's a simple example.
```
def grandiose_print(thing):
	print("\n" + '#' * 40 + "\n")
	print(thing)
	print("\n" + '#' * 40 + "\n")
	
```
After executing this code, I can do:
```
>>> grandiose_print('hello')

########################################

hello

########################################

```
Not a very useful function, I'll admit, but it demonstrates the concept.

To make a function return something, use the `return` statement:
```
def average(nums):
	return sum(nums) / len(nums)
```
Now, we can do:
```
>>> result = average([3, 5, 8])
>>> result
5.333333333333333
```

Note that if a function doesn't have a `return` statement, it just returns `None`. (It also returns `None` if you just write `return` without saying what to return. There is a use for this, which you'll soon figure out if you haven't already.)

# Why use functions?

Functions provide two main benefits: encasulation and abstraction. <!---->

The most obvious use of functions is to avoid repetition. If you have a program that does the same thing in a lot of places, you can put the duplicated lines in a function, and just call the function every time instead of repeating its source code.

But there's another tremendous benefit to using them, which is of [readability](readability). Even if a function is only used once, it can still be better than not making it a function, because it can make the logic of the program easier to follow. If you have 100 lines of code in a row that perform a task that can be divided into three phases, try making each phase a function. Then the main part can just look like:
```
phase1()
phase2()
phase3()
```
Which makes it easier to see what it's doing at a glance. In a program of any significant size, being able to "zoom out" and see the logic from a higher-level perspective is essential to keeping track of it.

# Multiple arguments and return values

A function can take multiple arguments, like `list.insert` does.
```
def find(string, substr):
	if substr in string:
		return print(substr, 'is in', string)
	if substr.lower() in string.lower():
		return print(substr, 'is in', string + ', but not the same case')
	print(substr, 'is not in', string, 'at all')
```
Since `print` returns nothing (meaning it returns `None`), `return print(...` just calls `print` with the given argument and then again returns `None`. Note that I don't use `elif` and `else` here, but the function works as intended. That's because once the function hits a `return` statement, it stops and returns, so it doesn't even check the other conditions. This pattern of using `return` under each case as an alternative to `elif` / `else` is not uncommon, although in this particular case it might've been clearer to use `elif` and `else`. I just wanted to show you this is a thing. The main draw is normally that if there's a lot of code in the function after an `if` block, `return`ing inside the block saves you from having to indent the rest of the function under an `else`.

You can also return multiple values:
```
def remainder_div(dividend, divisor):
	return dividend // divisor, dividend % divisor
```

And this is where we need to talk about unpacking tuples.
```
>>> a, b = (3, 6)
>>> a
3
>>> b
6
```
Well did you know you could do that? It's very useful with functions that return multiple values, as, the multiple values are actually returned as a tuple. Going back to `remainder_div`:
```
>>> remainder_div(5, 2) # we'll get a tuple
(2, 1)
>>> quotient, remainder = remainder_div(5, 2)
>>> quotient
2
>>> remainder
1
```
I don't think I've shown you any builtin functions up to this point that return multiple values, but it's a good tool to have.

# Default arguments

Check this out:
```
def greet(name = 'mate'):
	print("Hello,", name + '.')
```
Now you can use this to greet people and it'll just address them as "mate" if you don't specify their name.
```
>>> greet("Bob")
Hello, Bob.
>>> greet()
Hello, mate.
```
To give one example of a builtin function (a method) that has a default parameter, `list.sort`.
```
>>> l = [4, 2, 3, 2]
>>> l.sort()
>>> l
[2, 2, 3, 4]
>>> l.sort(reverse = True)
[4, 3, 2, 2]
```
By default, `sort` sorts in ascending order, because its `reverse` parameter defaults to False. But if you pass it True, it sorts in descending order.

## Variadic arguments

Okay, these two features aren't useful that often, but I might as well teach them while I'll talking about functions. After all, you've already seen a function that uses both, and I don't want to keep you from unlocking its full power any longer :P
```
def new_average(*nums):
	return sum(nums) / len(nums)
```
What's this? It's the same as the `average` function we wrote earlier, but it uses that weird `*` in front of the parameter name. That makes the parameter *variadic*, which means the caller can pass a varying number of arguments to `nums` and `nums` will be a tuple that contains all of them.

But this means we don't have to wrap our numbers in a list or tuple to call it (In fact, we can't):
```
>>> new_average(1, 5, 6)
4.0
>>> average([1, 5, 6]) # the old average function from earlier
4.0
```
Which looks nicer to call?

This is how `print` works, of course. You don't need to wrap your argments in a list to pass multiple things to `print`.

## Keyword arguments

You don't actually have to pass arguments in order, generally. There's another way to make sure you're passing the right ones.
```
>>> def print_two(a, b):
...   print("a is", a, "and b is", b)
...
>>> print_two(b = 'for banana', a = 'for apple')
a is for apple and b is for banana
```

In fact, `print` has not one but *two* parameters with default values that you can only pass this way because the main parameter (the stuff to print) is variadic. You know how it always prints a newline after it even if your string doesn't end in a newline? (Keep in mind that a newline is not a blank line. A blank line is two newlines in a row.) You can stop this by setting the `end` parameter to an empty string:
```
print("message 1", end='')
print("message 2", end='')
print("message 3", end='')
```
This will print:
```
message 1message 2message 3
```
It also has the `sep` parameter, which controls what gets printed between each argument. `sep` defaults to `' '`.

## Arbitrary keyword arguments

Okay, one last trick about arguments. There's a rarely useful thing you can do that's like a fusion of keyword and variadic args:
```
>>> def test(**args):
...   for key in args:
...     print('the argument', key, 'was passed', args[key])
...
>>> test(a = 'apple', b = 'banana')
the argument a was passed apple
the argument b was passed banana
```
Get it? The double-asterisk makes it a dictionary! You can pass any arguments you want to the function, and it's just like passing the dictionary but the syntax can be nicer sometimes.

# Scoping issues

Okay, now we're going to deal with a conceptual hurdle that accompanies functions. Scoping isn't as difficult to get the hang of as shared reference if you ask me, but it's still a stumbling block for many people (sure was for me).

You might've noticed that variables assigned inside of a function don't stay set outside of it:
```
>>> def f():
...   test = 5
...   print(test)
...
>>> f()
5
>>> # 5 was printed, so the assignment obviously worked. Let's see if we can access it now.
>>> test
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'test' is not defined
```
Well isn't that strange!

The `global` keyword can be used to allow a function to assign to variables outside of it.
```
>>> def f():
...   global test
...   test = 6
>>> f()
>>> test # this time, it affected the name outside of the function, because we made it a global name.
6
```

<div class="highlight" markdown="1">
Note that you *can access* global variables from inside a function, you just can't *assign* them.
</div>

# Closures

Closures are rather confusing, rarely used, and it's okay if you find them difficult to understand at this point. But you can define a function inside a function and even return it.
```
>>> def make_greeter(prefix, suffix):
...   x = 0
...   def greeter(name):
...     print(prefix + name + suffix)
...   return greeter
...
>>> melancholy_greet = make_greeter('hi, ', '...') # melancholy_greet becomes a reference to the function returned by make_greeter...
>>> melancholy_greet("Bob") # ... and we can call like a normal function!
hi, Bob...
>>> upbeat_greet = make_greeter('Howdy, ', '!')
>>> upbeat_greet("Bob")
Howdy, Bob!
```
See how that's working? `make_greeter` returns a function, and we can use it to get different greeter functions by passing different arguments to `make_greeter`. I think the reason it's called a closure is because you "close" the parameters into the inner function, essentially baking them into its code so the returned function can have those parameters without needing to be passed them on each call.

(You can also pass functions as arguments to functions, by the way.)

There's also the `nonlocal` keyword. Somebody on Stackoverflow called Anon wrote such a perfect concise explanation of the difference between `nonlocal` and `global` that I'll [just link it](https://stackoverflow.com/a/1261961/12211329).

Here's a possible use of closures with `nonlocal`:
```
>>> def get_counter():
...   x = 0
...   def counter():
...     nonlocal x
...     print("incrementing from", x, "to", end=' ')
...     x += 1
...     print(x)
...   return counter
...
>>> counter1 = get_counter()
>>> counter1()
incrementing from 0 to 1
>>> counter2 = get_counter()
>>> counter2()
incrementing from 0 to 1
>>> counter1()
incrementing from 1 to 2
>>> counter1()
incrementing from 2 to 3
>>> counter2()
incrementing from 1 to 2
>>> counter1()
incrementing from 3 to 4
```

# Docstrings

The point of docstrings over comments is that the `pydoc` command-line tool displays docstrings.
<!---->

# `import`

The `import` statement includes code from another file into your program. For example, let's say you had a function you used a lot and that you expected to use in future projects too. You write a module called something like `util` (for 'utilities' - this is a common abbreviation in programming):
```
def ask_bool(question):
	"""Asks the user a boolean question, and waits until they enter an answer
	   that can be interpretered as 'yes' or 'no'."""
	while True:
		entry = input(question + '(y/n) ').lower().strip()
		if entry in ('y', 'n', 'yes', 'no'):
			return entry in ('y', 'yes')
		print("not a valid answer.")
```
This could be a useful function for any command-line program that might need to ask its user a boolean question, which is probably a lot of programs. So you put this in your `util.py` file. Then, in your main file, you could write:
```
import util

# Some code

answer = util.ask_bool("Are you sure?")

# Some other code
```

The Python interpreter ships with a massive **standard library**, which is a collection of builtin modules you can import. Let's finally introduce the `random` module.
```
>>> import random
>>> random.randint(1, 5) # results may vary ;)
4
>>> random.randint(1, 5)
4
>>> random.randint(1, 5)
5
>>> random.randint(1, 5)
3
>>> random.randint(10, 20)
12
```
`random` provides lots of functions related to randomness, `randint` isn't the only one. For example, `random.random()` returns a random float between 0 and 1. `random.choice` is a shortcut that takes a sequence and gives you a random element from it, by generating a random int between 0 and the length of the sequence and then indexing.

We're gonna use this in our project, and it's gonna be *fun*...

# `from`, `as`, and `*` imports

One more think I better talk about while we're on imports. Three more things, actually. The `from` syntax allows you to import only some things from a module, but without the module name as a prefix (called a namespace prefix).
```
>>> from random import randint
>>> randint(1, 5) # this doesn't need to be prefixed with 'random.' this way
2
>>> choice(('a', 'b', 'c')) # but now we don't have access to this
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'choice' is not defined
```
If you want to import everything from a module without the namespace prefix, you can use `from module import *`. Go ahead and try it.

`as` lets you import a module with a different name:
```
>>> import random as r
>>> r.randint(1, 5)
```
The most common time I use this is when I'm experimenting in the prompt and just want to import a module with a one-letter name so I do as little as typing as possible.

# Tic Tac... Toe?

Would you believe you have the skills to write a tic tac toe game, complete with an AI that makes intelligent moves? Because you do.

This is a much larger project than anything we've done before, which calls for some planning. Programmers often use "pseudocode" to plan out how a program's going to work before we start writing it. Here's some pseudocode:
```
Explain to the player how they'll enter their move in the text-based interface.
Ask them whether they want to go first.
While neither player has won and the board isn't full:
	Let whoever's turn it is make a move
	Switch who's turn it is
Show the final state of the board and congratulate the winner.
```
This kind of skeleton can be very useful; if you dive into writing code without an idea of how it's going to work, you'll often regret it. You'll probably want a function to check whether the game has an outcome yet, and if so who. Getting the player's move and determining the computer's move should also be in functions. Which leads me to the other big obstacle: the AI.

Writing AI for Tic Tac Toe is a lot simpler than it sounds.
