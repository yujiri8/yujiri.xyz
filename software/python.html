TITLE Python Review
NAV Review: Python
TEMPLATE DEFAULT

<h1>How Python and I met</h1>
<p>
I'm going to go on a pretty long tangent here. The first time I tried to learn programming, I was 10 and immature on top of
having a bad teacher and the incredible misfortune of starting out with C++ in JGrasp on Windows. I enjoyed it at first
but after the frustration of inscrutable error messages, my own lack of diligence, some arguments with
my teacher about indentation and him giving me assignments I wasn't interested in, and never being able to see how the
calculator and rock paper scissors programs I was writing could relate to anything practical, I quit.
</p><p>
Some time later, probably between 2 and 3 years, I tried again, this time with Java, using the BlueJ IDE. That lasted an
even shorter time. Actually my memories are a bit blurred around this time period - I remember trying to learn Java on my own
and lasting less than a week but also the same teacher trying to teach it to me, and getting far enough that we started working
on a game we came up with called City Wars in the Netbeans IDE (but I still dropped it; we took on the project solely as a
result of him being grossly overconfident in my abilities and doing 90% of the work because I couldn't understanding a thing he
was doing). I'm not exactly sure how all that fits together; there might have been a few days or a year's gap between the two
forays into Java.
</p><p>
Fast-forward to when I'm 15, my old teacher sent me a book: <i>Python Programming For The Absolute Beginner</i> by Michael
Dawson. He told me I might like Python because "it does a lot <i>for</i> you". And lo and behold, was he right. Before long I
had written a Hangman game and a Tic Tac Toe game almost completely on my own (and not too long after that <a
href="https://github.com/yujiri8/pixeldodge">Pixeldodge</a>) and grown to like Python far more than I ever had C++ or Java.
Obviously this wasn't entirely the languages' fault; me being much older and more mature was also a big factor as was having a
book specifically geared toward my sweet tooth of game programming. But to this day I feel a sense of allegiance to Python,
since it was the third language to try to teach me programming and the first to succeed. And Python was the only one that had to
do it almost entirely without human guidance (my teacher was no longer over my shoulder).
</p><p>
To this day I retain the belief that, at least of the languages I've seen, Python is the one true language for learning to
program. Every other language is a vastly inferior gateway into the art. The two main reasons are the ability to use it
interactively and the general lack of boilerplate, which I'll discuss at greater length.
</p>
<hr>
<h1 class="good">The Interactive Prompt!</h1>
<p>
Interactive interpretation, is, obviously, a huge advantage. It lets you try things out on the fly to learn more about the
language or check that something works the way you think it does without writing a file and running it and then removing it,
and sometimes it can even be used to aid debugging by passing the <code>-i</code> flag when running a program, which gets you
a prompt after the program exits with any names in it still defined (although the usefulness is limited by that only global
names will be accessible, but this has really helped me in real-world use).
</p>
<h1 class="good">Conciseness</h1>
<p>
A lot of common tasks that take for loops or verbose idioms in other languages are zinging one-liners in Python.
</p>
<ul>
<li>Sort a sequence: <code>sorted(seq)</code>, or <code>l.sort()</code> to sort a list in-place</li>
<li>Reverse a sequence: <code>reversed(seq)</code>, or <code>l.reverse()</code></li>
<li>Insert into a list: <code>l.insert(index, item)</code></li>
<li>Delete an element from a list by value: <code>l.remove(item)</code></li>
<li>Delete an element from a list by index (and return it!): <code>l.pop(index)</code></li>
<li>Negative indices, slice steps? You got it. <code>l[-2:-6:-1]</code> (Though I've never once found an occasion to use slice
steps.)</li>
<li>Generic functions for finding the max or min value of a sequence of any type? <code>max()</code>, <code>min()</code></li>
<li>Read a line of console input? <code>entry = input(prompt)</code></li>
</ul>
<p>
I don't know any other language that handles all these tasks as elegantly as Python. It also doesn't require you to define a
"main" function, nor to import a couple of modules before you can do really anything at all (like <a href="go">Go</a> does).
And I'm not saying those latter two things are pointless bad design, but they make it harder to write a simple test program
quickly, which is part of what makes Python such a great tutorial language and the interactive prompt so useful.
</p>
<h1 class="good">Beautiful error handling</h1>
<p>
Python gives you nice stack traces and line numbers on exceptions without you lifting a finger. You can also throw errors with
custom context really easily with <code>raise</code> ... <code>from</code>, and the <code>finally</code> statement is convenient
for making sure something gets executed on the way out, like closing a file. It's not quite as versatile as Go's defer statement
since you can only use finally in the context of <code>try</code> ... <code>except</code>, but given how many orders of
magnitude easier it is to get good tracebacks in Python, you really can't complain. No other langage I've seen makes error
handling anywhere near this easy. 90% of the time you don't even have to think about errors. Usually what you'd do in Go or C is
just throw the error anyway, so Python saves you a tremendous amount of time and boilerplate in favor of sensible default behavior.
</p><!--except: ... raise is useful-->
<h2 class="good">Streamlined and readable syntax</h2>
<p>
Python's syntax is great for a lot of reasons.
</p>
<ul>
<li><p>
<b>Uses indentation to mark code blocks.</b> You always want to indent your code anyway in a language that uses braces,
so why not just have the parser use that to tell where a block ends?
</p><p>
Another advantage besides the parsimony appeal is that in a language that relies on braces for this, you often get syntax
errors due to forgetting one or whatnot, and when that happens the error message frequently points to a line that
isn't causing the problem. Those don't usually take more than a minute to track down but they're annoying, and in Python
they're a lot less common because indentation not only is more visually apparent but leads to far better error messages
when you get it wrong.
</p></li><li><p>
<b>No completely unnecessary semicolons and parentheses.</b> It seems like everybody who makes a language after C decides it
needs to copy over all of C's syntactic noise and require a semicolon after every statement, even though parsers are
well capable of telling where a statement ends without that; and the incessant parentheses around
every if or for condition. They take time to type and time to look at. I've yet to hear any argument that there's any kind of
benefit to C-style syntax.
</p></li><li><p>
<b><i>English.</i></b> Python's boolean operators are <code>and</code>, <code>or</code>, and <code>not</code>, instead of the
more traditional <code>&&</code>, <code>||</code>, and <code>!</code>. Humans read English, so a programming language that uses
English words to express concepts that correspond easily to them is always going to be more readable. The faster you parse the
characters on the screen as a logical concept, the more efficient you'll be. Especially the for loop: what alien in the universe
would rather read <code>for (let i = 0; i < seq.length; i++) {</code> than <code>for elem in seq:</code>? The line literally
says what it does instead of making you parse out three separate statements each full of non-English symbols. And if you want
the counter explicitly you can do <code>for i, elem in enumerate(seq):</code>.
</p><p>
Also, perhaps counterintuitively, <code>and</code> and <code>or</code> are <i>significantly faster to type</i> than <code>&&</code>
and <code>||</code>. <code>&&</code> and <code>||</code> are the same number of keypresses as <code>and</code>
since they require shift, shift is usually slightly slower to hit than a letter, and the second and third keypress
are the same key, which prevents use of multiple fingers to accelerate your typing.
</p></li>
</ul>
<h2 class="good">Generators and comprehensions</h2>
<p>
Generators and comprehensions are a pretty nifty pair of features with a lot of advantages.
In a lot of ways they function like a more readable version of map/filter from functional languages
(although Python also has those functions). For example:
</p>
<pre class="code">
l = [num*100 for num in range(10) if num % 2 == 0]
</pre>
<p>That's equivalent to:</p>
<pre class="code">
l = list(map(lambda num: num*100, filter(lambda num: num % 2 == 0, range(10))))
</pre>
<p>
Not only does the generator/comprehension implementation do both operations in one, but again the familiar English words
<i>in</i> and <i>if</i> are more readable than "list... map... lambda... filter... lambda... wait what is this doing again?".
And then that nauseating stack of parentheses that you'd probably miscount the first time and get a syntax error.
</p><p>
Generators are also <i>lazy evaluation</i>. Since they don't compute the entire thing up-front but just let you iterate over the
sequence, you can use generators to deal with a large (or even infinite) sequence without storing it all in memory. (And in fact
map and filter are both implemented as returning iterators in Python 3.) The end of <a
href="https://www.programiz.com/python-programming/generator">this article</a> shows a great example of how useful this can be.
</p><p>
There's also the <code>yield</code> keyword to easily turn a function into a generator.
</p><p>
In fact, I didn't find this out until recently but generators are actually coroutines. You can catch a return value from
<code>yield</code> and use <code>gen.send()</code> on the calling end to feed it values. I haven't gotten to use this yet,
but it sounds really cool.
</p>
<h2 class="good">Libraries for everything</h2>
<p>
Python is such a popular language that you can pretty much always find a library that does anything you need.
<a href="https://docs.python.org/3/library/index.html">The standard library</a> itself is so extensive, CSV, JSON, HTTP, TLS, emails,
regex, base64 and almost any other encoding you can think of are just a tiny fraction of what it can do out of the box.
If somehow you need something that isn't there it's probably pre-packaged in standard repositories for your
operating system. In the worst case it's available through <a href="https://pypi.org/project/pip">pip</a>,
Python's package manager.
</p><p>
From what I can tell Python's <code>ctypes</code> module is also quite effective at interfacing with C code without
native Python bindings. I haven't used it for much in practice, but I did play with it a little bit and it looks
amazing.
</p>
<hr>
<p>
Of course, there are also a lot of things I don't like about Python.
</p>
<h1 class="bad">Lack of compile-time sanity checking</h1>
<p>
The Python interpreter checks only for syntax while parsing your code. Did you forget the brackets and pass <code>var</code> to
a function when you meant to pass <code>[var]</code>? Have fun crashing at runtime when you get to that line. Did you pass the
arguments to a function in the wrong order? Have fun crashing at runtime. Hell, did you even misspell a name? Have fun crashing
at runtime once more and being told "name 'comprehnesion' is not defined" and staring at it for 15 seconds before realizing
what's wrong. Oh, and have fun with that you only find out about one of these each time the program crashes. If you have
multiple errors like this, you're gonna have to run the code multiple times to find out. God help you if you're writing a game
like <a href="https://github.com/yujiri8/spacestation-defense">Spacestation Defense</a> and the function you just added with all
these mistakes takes 30 seconds or more of clicking through menus and playing out the first couple turns to get to after game
start.
</p>
<h1 class="bad">Lack of static typing</h1>
<p>
This is a related point to the above, but they're different things. Python doesn't do any checking that values are of the
correct types; it'll happily let you assign a tuple to an object attribute that's supposed to be a list and then later in some
unrelated function tell you <code>'tuple' object does not support item assignment</code> with a stack trace that doesn't
include the line that caused the problem. Even worse when it <i>never</i> crashes, but instead causes some bizarre
functionality breakage; this kind of bug can take hours to track down in the worst cases.
</p><p>
When I was new to Python I actually loved this trait and argued that other languages were badly designed for
not allowing the programmer to mix types. "What if you need to have values of multiple types in a list, or a function
that takes a single argument of multiple types?" I asked. But is there actually <i>ever</i> a legitimate use case for that
kind of practice? After six years of Python experience, I'm not sure that there is. The only one I've ever found was using
values of different types to convey different meanings about what to do with the value (I used this technique frequently in
past versions of Spacestation Defense if I remember correctly), for example when sending actions to <code>gamestate.playout</code>,
if the value is a bool then it means to toggle whether the component is powered, and if it's a list then it's information about
what action that component should take this round. But using the type as part of the value contradicts the whole idea of a type.
That kind of solution is just a less clear alternative to a struct/dictionary-based approach (and I did end up converting it
to that).
</p><p>
I can see a possible case for a list of ints with <code>None</code> as a valid value, but other languages with static typing
have ways of accomplishing that. In Haskell for example you could use the <code>Maybe</code> monad. Then the type system would
provide you this flexibility while still making sure you won't have any type errors at runtime. In C you could use a struct
with fields <code>int value</code> and <code>bool valid</code> (or more probably a union; I haven't used unions in C yet but
from what I understand they exist to solve this very problem).
</p><p>
Of course, it's not as if this shortcoming could be easily removed from Python by adding compile-time type checks, because
Python doesn't have <a href="oop">any concept of interfaces</a>. It relies on this duck typing to not suffer a major
loss of polymorphism.
</p>
<h1 class="bad">Object-orientedness and inheritance are clunky</h1>
<p>
Honestly, I think that by having no static type checking, Python removes a lot of the benefits of using objects over
dictionaries. Here's what I see as the two biggest differences between structs and maps in a language like, say, Go, besides
having methods:
</p>
<ul>
<li><p>
Structs have an immutable field set. You can't assign to a nonexistent attribute of a struct, which provides mistake protection
and promotes clarity by making sure you can always see all the attributes an object might have just by looking at the struct
definition.
The Python interpreter doesn't complain in the slightest when you assign to <code>ship.sheild</code>,
leaving you with a very difficult-to-track-down bug.
</p></li><p><li>
Structs can have fields of mixed types, while map has to have all its keys be the same type and all its values be the same type.
There are uses for both. But Python, having no static typing, completely removes this difference and makes both types subject
to the same potential for mistakes and bugs.
</li>
</ul>
<p>
<!--In some ways I like the way Python thinks of everything as an object. It's more intuitive to me to have <code>split</code> be a
method of strings than to have it be a function that you pass the string to.-->
Also, constructor functions are rather boilerplate-esque in Python...
<!--I found out as of 2019 October 10 that you can actually omit the <code>__init__</code> header and use almost
exactly the C syntax, but then you can't pass arguments to its default values; every object of the class has to start
with the default values.-->
</p>
<pre class="code">
class A:
	def __init__(self, attr1, attr2, attr3):
		self.attr1 = attr1
		self.attr2 = attr2
		self.attr3 = attr3
</pre>
<p>
Really, we have to write the name of each attribute three times? This is one of the only areas where C is more streamlined than
Python, and it is more streamlined by <i>a lot</i>.
</p>
<pre class="code">
struct A {
	int   field1;
	int   field2;
	char  field3[10];
}
</pre>
<p>
Much better. To be fair, Python's way does allow to easily set non-zero default values for an object's attributes, which in C or
Go you'd have to write a wrapper constructor for. But that feature doesn't at all need this much bulk to accomodate it. They could
have just taken the C/Go syntax and added the option to put a default value after the field name.
</p>
<p>
And when you want to call a parent constructor, guess what you have to do? This:
</p>
<pre class="code">
class B(A):
	def __init__(self, attr1, attr2, attr3, attr4):
		super().__init__(att1, attr2, attr3)
</pre>
<p>
Yes, you have to explicitly call the parent constructor <i>and</i> pass in the entire argument list. As if that wasn't bad
enough, the syntax for calling the parent constructor looks like a hack. Nowhere else in Python is it idiomatic to directly call
the __...__ methods.
</p>
<h2 class="bad">Performance</h2>
<p>
Being interpreted at run-time instead of pre-compiled, Python is pretty much always going to be much slower than a compiled
language (I benchmarked it doing some repetitive math once and found it to be over 120x slower than Go). I think this is
just an acceptable loss when you decide to make an interactively interpretable language, although Haskell has shown that
it's possible to be both compilable to native code and interactively usable.
<!--(.pyc files aren't really compiled; they're just pre-parsed bytecode
that still needs the Python interpreter)-->
</p><p>
But Python's case is worse, because you can't really even make use of threading to overcome this - the Global Interpreter Lock
only allows one thread to execute Python code at a time. So you can have one thread doing computation and many other threads
waiting on IO at once, but if you want to actually use the parallel computing power of more than one core, you're going to have
to use multiprocessing or something. And that's a mess.
</p><p>
And to be fair, I'm not saying the GIL is a mistake Guido Van Rossum made. I read a little bit some time ago about the reasons
for implementing it and they seemed defendable, but this symptom is certainly a drawback.
</p><p>
Mitigating Python's performance limitations, (and this is why I made it an h2 heading) there does exist <a
href="https://pypy.org">PyPy</a>, an alternative interpreter for the language (the standard one being <a rel="nofollow"
href="https://en.wikipedia.org/wiki/CPython">CPython</a>). PyPy runs a <i>lot</i> faster - within a reasonable factor of Go and
C by my benchmarks - but it has some issues with compatibility; it <a
href="https://doc.pypy.org/en/latest/cpython_differences.html">doesn't use reference counting in its garbage collection which
can cause resource leak issues for some programs written for CPython</a>, and can't use certain modules for CPython that are
actually written in C (I ran into this with <a href="https://www.pygame.org">Pygame</a> when I was making Spacestation Defense).
PyPy also isn't <i>always</i> faster; it uses <a rel="nofollow"
href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT compilation</a> instead of being a true interpreter, so on
short scripts that execute in less than a second anyway it can actually be slower. And that's a lot of what Python gets used
for.
</p>
<h3 class="bad">Always needs the interpreter</h3>
<p>
As an ancillary drawback of being unable to compile, every Python program will always depend on having the Python
interpreter (and the right version of it) installed to run it. While this isn't a big problem in practice since seemingly every
operating system comes with Python installed these days or can easily install it from standard repositories, I still don't like
it on principle. If I made a programming language (which I'd like to do someday but not sure if I ever will) I would make it not
depend on being standard everywhere in order to run code without dependencies.
</p><p>
Having it be standard everywhere also doesn't completely fix the problem. When releasing <a href="/reviews/ddlc">Doki Doki
Literature Club</a> (which is built on Python &gt; Pygame &gt; <a href="renpy">Renpy</a>) Dan ended up shipping the Python
installation to get around version issues. On a Unix operating system your package manager would probably take care of that for
you, but in a world dominated by Windows we can't count on there being such a thing.
</p>
<h3 class="bad">Working with timestamps is a mess</h3>
<p>
Lately I've had the displeasure of working with timestamps in Python. It was a displeasure. There are several different ways of
representing them:
</p>
<ul>
<li><p>
	<code>os.stat</code> returns a <code>stat_result</code>, which has the file timestamps stored as massive floats
	of the seconds since the epoch.
</p></li><li><p>
	<code>datetime.datetime</code> is a class with eight constructor parameters: year, month, day, hour, minute, second,
	<i>microsecond</i>, and time zone (which can be <code>None</code>).
	</p><p>
	To get a <code>datetime.datetime</code> from the <code>os.stat_result</code>, the function you need is
	<code>datetime.datetime.utcfromtimestamp</code>. Yes... not the class constructor, not a function in the module,
	a method <i>of the class</i>. That's not even what a <i>class is</i>... if you designed your <i>class</i> to be
	used as if it were an object itself, then I have to say I think you misunderstand the point of the concept.
</p></li><li><p>
	Then there's <code>time.struct_time</code>, which is returned by <code>time.gmtime</code> and expected as input to
	<code>time.mktime</code>, which converts either one of those or a tuple to a numeric timestamp. Don't ask me why
	both this and <code>datetime.datetime</code> need to exist.
</p></li><li><p>
	Times are also sometimes represented as tuples. <code>email.utils.parsedate</code>, which I used to parse HTTP
	<code>if-modified-since</code> before I found out about <code>email.utils.parsedate_to_timestamp</code>, returns
	a tuple of nine elements. After the year, month, day, hour, minute, and second, it returns <code>0</code>,
	<code>1</code>, and <code>-1</code>, seemingly regardless of the input and the <code>pydoc3.6</code> output for the
	function doesn't say anything on it. (It literally just says "Convert a time string to a time tuple.")
	</p><p>
	Well if you go to <a href="https://docs.python.org/3/library/email.utils.html#email.utils.parsedate">the online docs</a>,
	it explains that "Note that indexes 6, 7, and 8 of the result tuple are not usable." Great documentation, guys! They're
	not usable? What do you mean? What do they even represent? Apparently <i>not</i> timezone, since
	<code>email.utils.parsedate_tz</code> exists and returns a 10th element that represents that?
	</p><p>
	Also, there's <code>email.utils.parsedate</code> and <code>email.utils.parsedate_tz</code> and
	<code>email.utils.parsedate_to_datetime</code> but no <code>email.utils.parsedate_to_datetime_tz</code>? Why?
</p></li>
</ul>
<p>
</p>
<h3 class="bad">Mutable default arguments</h3>
<p>
I debated about putting this on here, but I think it's a sufficiently crazy gotcha to be counted as a criticism that default
arguments persist if they're mutable data structures. If you have a function with an argument that defaults to <code>[]</code>,
and you call the function in such a way that it ends up modifying that list, the next time you call the function it'll default
to the damn modified version. I can't see when this would ever be the desired behavior and it's extremely counter-intuitive.
I ended up getting around it by having the arg actually default to None and then <code>if arg == None: arg = []</code>.
That's a hacky solution.
</p><p>
And yes, I do know why this is the case (functions are objects), but that doesn't make it a good behavior or not extremely
confusing for people who haven't run into that yet. And moreover it's possible to become quite proficient in Python without
acquiring the understanding that functions are objects (I sure didn't until I'd been using it for a few years).
</p>
<h3 class="bad">Single versus double quotes - meaningless decision</h3>
<p>
Okay, this is a <i>really</i> small nitpick, I admit. But it bothers me to have two options that are functionally equivalent but
neither is obviously better (single-quotes are easier to type but more likely to require escaping). It raises the question of
"which one should I use?" and so I have to spend time making that decision every time I type a string. And the decision never
really matters, but inconsistency in coding style bugs the hell out of me, as I believe it does out of most programmers, so I
wish strings just had to use one or the other and the other would have a different meaning. It's not entirely obvious what;
maybe single-quotes could be byte strings (instead of <code>b'text'</code> being the literal syntax for byte strings) and
double-quotes could be Unicode strings? IDK. But this violates the <a href="https://www.python.org/dev/peps/pep-0020">Zen of
Python</a> principle that "There should be one-- and preferably only one --obvious way to do it."
</p>
<br><hr><br>
<p>
So in conclusion, yes, I do think Python is a good language. Especially for learning, but by no means only for that. It's even
still my favorite, although I wouldn't be surprised if Haskell overtakes that position once I learn more about it.
</p>
