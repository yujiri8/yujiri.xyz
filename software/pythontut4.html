TITLE The Concise Python Tutorial, part 4: Mutable types
NAV The Concise Python Tutorial, part 4: Mutable types
TEMPLATE DEFAULT
MARKDOWN

[Previous lesson: Sequences](pythontut3)

Last time things were starting to get interesting. This time we're going to introduce a few more data types, some of which are *mutable*, which starts to introduce the concept of object identity or reference.

# Lists

The first data type is lists, which are mostly the same as tuples but way more useful in practice. The syntax for list literals uses brackets instead of parentheses:
```
>>> nums = [1, 7, 4]
>>> nums[2]
4
>>> nums + [3, 13]
[1, 7, 4, 3, 13]
```
Indexing, slicing, and the rest of the bag work exactly the same as they do on tuples, and you can have lists of lists, or lists of tuples, or tuples of lists.

So what's the big difference?

# Mutability

If you played with tuples and strings, you might've noticed that you can't assign to individual items in them:
```
>>> nums = (1, 2, 4)
>>> nums[1] = 3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> word = 'hello'
>>> word[2] = 'x'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```
(If this were possible, I would've given you an assignment involving it for part 3.)

And that's what's so important about lists: they're mutable.
```
>>> nums = [1, 2, 4]
>>> nums[0] = 1.5
[1.5, 2, 4]
```
So you might be wondering why you would ever use tuples. Well, there at least two reasons you might want your data structures to be immutable. One is if the data is supposed to be a constant, and any modification of it would certainly be a mistake. You might want to just make the list immutable to make sure you don't accidentally modify it. <expand-note>(Some languages offer a way of making it actually impossible to change a variable's value, but Python does not.)</expand-note> (Immutable data types also have better performance if you aren't going to modify them.) The other big reason is to avoid shared reference.

# Shared reference

Get ready for something really hard. Remember when I told you that `x += y` is just shorthand for `x = x + y`? That was kind of an oversimplification. It's only true *for immutable data types*. But for mutable things like lists, there's a difference.

Mutable data types exhibit **shared reference**. With immutable types, if you assign one variable to another, and then change one, the other stays:
```
>>> x = 5
>>> y = x
>>> x += 1
>>> y
5
>>> words = ('hi', 'hello')
>>> words2 = words
>>> words += ('hey',)
>>> words2
('hi', 'hello')
>>> words
('hi', 'hello', 'hey')
```
They don't stay linked. Lists, however:
```
>>> words = ['hi', 'hello']
>>> words2 = words
>>> words += ['hey']
>>> words2
['hi', 'hello', 'hey']
>>> words
['hi', 'hello', 'hey']
```
It changed both! That's because there was actually only ever one list. `words` was set to refer to a list, then `words2` was set to the value of `words`, so when you change one, both names see it as changed. Whereas with tuples or strings or ints, since they're immatuable, when you do `words2 += ('hey',)`, what's really happening is that it expands to `words2 = words2 + ('hey',)`, so a second tuple is being created that consists of `words2 + ('hey',)`. When `words2` is a list, on the other hand, `words2 += ['hey']` concatenates `['hey']` to the *existing* list stored in `words2`. We call it adding `in-place` or *mutating* the existing list, as opposed to making a new one and assigining the new one to the same variable.

But then there's this finding:
```
>>> words = ['hi', 'hello']
>>> words2 = words
>>> words2 = words2 + ['hey']
>>> words
['hi', 'hello']
>>> words2
['hi', 'hello', 'hey']
```
If you use `=` (not `+=`), `words2` is reassigned and stops referring to the same list as `words`. I told you the simplified story earlier because for immutable data types, it doesn't matter.

To understand how this works, you need to understand the difference between a variable and its value. Variables in Python are nothing more than names. If you do `nums = [1, 2, 3]` and then later `nums = [4, 5, 6]`, you don't change the list, you change `nums`. This distinction is important. The list itself is a block of data stored in memory somewhere. The new list is stored in a different memory location. But when you do `nums2 = nums`, `nums2` refers to the same underlying data as `nums`, not an identical copy.

The `is` operator is really useful for understanding this:
```
>>> list1 = [1, 2, 3]
>>> list2 = [1, 2, 3]
>>> list1 == list2
True
>>> list1 is list2
False
```
`==` checks whether two values are *equal*. `is` checks whether they're *the same*. If you do this with tuples you'll find that `tuple1 is tuple2` would be True. That's because, since tuples are immutable, when you assign the same tuple literal to two variables, Python doesn't make a second copy in memory; it just sets both variables to point to the same object. But when you do it with lists, Python has to assume you want them to be able to change independently, so it has to make a second copy.

It's important to understand that *shared reference is good sometimes and bad other times*. Sometimes you want to change a list in one part of a program and want other places that deal with the same list to see the change. Other times you want them to stay separate even if their values happen to start out equal. When you set one variable to another one that refers to a mutable object, it shares the reference by default, but there are ways to make a distinct copy if you don't want that (without retyping the literal value). For example, `list2 = list1[:]` would make `list2` a separate but identical list. Changes to one after that would not affect the other.

If shared reference is still confusing to you, you're not alone. I was still tripping over this after a couple years of knowing Python (I think I'm over it now). But it'll come with practice. For now, let's go on.

### Converting between lists and tuples

By the way, you can use the `list` or `tuple` functions to convert between lists and tuples, or to convert strings to either (but using `str` on a list or tuple doesn't do what you might expect - it gives you the representation you get when you print them).

# Methods

I didn't really want to talk about methods until we got to objects or at least to functions, but oh well, I can't avoid this any longer. For now, let's just say that methods are basically functions attached to a specific data type and with a special `.` syntax. Here's an example:
```
>>> nums = [5, 4]
>>> nums.remove(5)
>>> nums
[4]
```
So lists have this `remove` method that takes a value and deletes the first element in the list that is that value. (It does only get the first one; if `nums` were `[5, 4, 5]`, it would've been `[4, 5]` after the operation.)

<div class="highlight" markdown="1">
**Important jargon**: the value a function **returns** is the value it's replaced with when you execute it. For example, `input` *returns* the text entered.**
</div>

The `remove` method of lists doesn't return anything.

Strings have a few cool methods I didn't mention before (no need to memorize all these):
```
>>> word = 'hello'
>>> word.index('e')
1
>>> word.count('l')
2
>>> word.startswith('h')
True
>>> word.endswith('o')
True
>>> word.replace('l', 'x') # note that this doesn't modify the word, as I'll show on the next line
'hexxo'
>>> word # original word is unchanged. The method returns a new string.
'hello'
>>> sentence = "Hello, my friend."
>>> sentence.split(' ')
['Hello,', 'my', 'friend.']
>>> sentence.upper()
'HELLO, MY FRIEND.'
>>> sentence.lower()
'hello, my friend.'
>>> sentence.title()
'Hello, My Friend.'
```
And many others. Lists and tuples also have `count` and `index`.

# Other useful list methods

* `list.append(value)` - adds the value to the list in-place. Note that this way, you don't have to put brackets around it.
* `list.pop(i)` - removes the element at position `i` (default `-1`), and return it.
* `list.reverse()` - reverses it in-place
* `list.insert(index, value)` - inserts the given `value` at the given `index`.
* `list.clear()` - removes all elements. The difference from reassigning `[]` to the variable name is that reassigning breaks shared references: `list.clear()` changes the list in-place.
* `list.copy` - doesn't modify the list, but returns an exact copy of it. This is used to get around shared reference, since the copy is a *distinct* list even if it's identical. (This can also be done with `list[:]` - using slicing to create a new list with all the same elements.)

Even ints and floats have some methods, but they're all pretty obscure.

# Dictionaries

Another crucial data type is the dictionary. Dictionaries are basically sets that also store a corresponding value for each key, and you can lookup by by key:
```
>>> spanish = {'casa': 'house', 'hola': 'hello', 'si': 'yes'}
>>> print(spanish['casa'])
'house'
```
How neat is that!

Dictionaries don't respect order, by the way, so `{'a': 'z', 'b': 'y'}` and `{'b': 'y', 'a': 'z'}` are identical dictionaries.

Dictionaries (usually just called dicts) don't store duplicates, so when you assign to a key, it gets that value regardless of what it had or whether it existed before:
```
>>> spanish['hablar'] = 'talk'
{'casa': 'house', 'hola': 'hello', 'si': 'yes'}
>>> spanish
{'casa': 'house', 'hola': 'hello', 'si': 'yes', 'hablar': 'talk'}
>>> spanish['hablar'] = 'speak' # the verb more or less covers both English words
>>> spanish
{'casa': 'house', 'hola': 'hello', 'si': 'yes', 'hablar': 'speak'}
```
To remove a key from a dictionary, you can use `del`:
```
>>> del spanish['hola']
>>> spanish
{'casa': 'house', 'si': 'yes', 'hablar': 'speak'}
```
When you try to access a dictionary key that doesn't exist, you get an error:
```
>>> spanish['entender'] # it means 'understand', by the way, but I haven't put it in the dictionary
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'entender'
```

Useful dict methods:

* `dict.get(key)` - like accessing the key, but if the key doesn't exist, you'll get `None`.

I guess now that you know dicts, there's one more case where you would use tuples instead of lists: dictionary keys can't be lists, other dicts, or other built-in mutable types. This is probably a consequence of how the dictionary is stored in memory (and I couldn't explain to you exactly why), but it is, so you can use tuples if you want a sequence of values to be a dict key.

### Iterating on dicts

`for` and `in` both treat dicts as sequences of keys, so:
```
>>> 'casa' in spanish
True
>>> 'house' in spanish
False
>>> for word in spanish:
...   print(word, 'means', spanish[word])
casa means house
hola means hello
si means yes
hablar means speak
```

<!--
# Sets

There are also sets, which are sets in the mathematical sense:

<div class="highlight" markdown="1">
Note that since `{}` is interpreted as the empty dictionary . There is no empty set literal. To make an empty set you have to use `set()`.
</div>

Sets don't respect order (so `{1, 2, 3} == {1, 3, 2}`), and like dictionaries, don't allow duplicates.

Sets are also mutable .
-->

## Comparing other types

While we're at it, it's about time I mention that all of the comparison operators work on things besides numbers. On strings, the greater-than and less-than operators treat strings as if characters with higher values are 'greater' - in other words, they alphabetize them. Actually, that's an oversimplification.

You might have already heard of [ASCII](https://en.wikipedia.org/wiki/ASCII). Internally, a string is a sequence of bytes, each one representing a character. For example, the byte `1100001` (97 in decimal) is `a`. (`A` is `1000001` - 65.) The full ASCII table is [available here](http://www.asciitable.com), or on countless other websites. <expand-note>Technically, Python strings use UTF-8, not ASCII. But that's a discussion for another time, and UTF-8 is fully backward-compatible.</expand-note>

For Booleans, `True` is considered greater than `False`. In fact, if you play around besides the code I'm showing you, you might've already noticed that `True` and `False` can be used as `1` and `0`. If you didn't, try `print(True + True + False + True)`.

For a list or tuple, comparison is done by comparing each element in sequence, and the first time it finds a pair that isn't equal, the list with u. This behavior can be thought of as a generalization of how string comparison works, although a string is not the same as li s or tuple of characters. <expand-note>In many other languages, there's a separate `char` data type, and a string is a list of `char`s. But in Python, strings are their own data type.</expand-note>

# Score reporter!

Here's a (hopefully) fun assignment. Write a program that lets a group of people each enter their names and a list of scores they got. Then, when the (user)s confirm they're done, print the highest score and the name of the person who got it, and the average score and the number of scores of each person.

Some functions that will help you here are the builtin `max` and `sum`, which take a sequence of any type and give you the max or total value, if applicable. (If you use them on a sequence of values that can't be compared, like `max([4, 'a'])`, you'll get an error.) You can do it without these, by implementing their logic yourself, but using the builtin ones will save you some effort.

```
# The value of each key will be a nested dict of all the player's data: 'scores', 'max', and 'average'
data = {}

while True:
	name = input("Enter your name (blank to finish):")
	if not name: break
	data[name] = {'scores': []}
	while True:
		score = input("Enter a score (blank to finish):")
		if not score: break
		data[name]['scores'].append(int(score))
	# now that we have all their scores, compute stats for them
	data[name]['average'] = sum(data[name]['scores']) / len(data[name]['scores'])
	data[name]['max'] = max(data[name]['scores'])

grand_max = {'name': '', 'score': 0}
for player in data:
	if data[player]['max'] > grand_max['score']:
		grand_max = {'name': player, 'score': data[player]['max']}

print("The highest score ever was", grand_max['score'], "by", grand_max['name'])

print("Everyone's average score:")
for player in data:
	print('\t' + player + ":", data[player]['average'])

# use comapring other types
# use item assignment
# use item deletion, lots of methods
```
