TITLE Unix process streams explained
NAV IO and standard streams
TEMPLATE DEFAULT

<p>
<b>I/O</b>, or <b>IO</b>, stands for input/output. Anything a program does that affects or uses something outside of its own
memory, like writing data to a file, or using a device (such as playing audio), is I/O.
</p><p>
Some terms you'll encounter a lot in the Unix world are <i>stdin</i>, <i>stdout</i> and <i>stderr</i>. These stand for
standard input, output, and error, and are the main ways processes do I/O. For example, the <code>cat</code> command
after reading the named file writes its contents to stdout. Normally when you run <code>cat</code> in a terminal its stdout
will be the terminal, so you'll see the text of the file appear on screen. But you can make it go somewhere else instead.
</p><p>
The <code>|</code> character (that's a pipe, not a 1, I, or l) is the symbol used by most <a href="shell_basics">shells</a>
to redirect a command's stdout to be the stdin of another command. For example, if you have a progam called <code>sendemail</code>
that lets you type text when you run it and then sends it as an email, but you want to automatically feed it the contents of a
file named <code>letter</code>, one way to do it is:
</p>
<pre class="code">cat letter | sendemail</pre>
<p>
<code>sendemail</code> will run as if you had manually typed the contents of <code>letter</code> into it, and you won't
have to do anything else.
</p><p>
This would be extremely useful, except that most Unix commands I can think of that you would want to <code>cat</code> a file
into support just giving it the filename as an argument, making <code>cat</code> unnecessary. Piping is super
useful in general though; just not with <code>cat</code>. (<code>grep | less</code> is a common example of where it's useful.)
</p>
<h2>So what's stderr?</h2>
<p>
Stdout is for normal output - the expected output of a command. Commands write to their stderr stream instead of stdout if
they fail. For example, if you try to <code>cat</code> a file that doesn't exist, <code>cat</code> will print an error message,
and it'll still show up in the terminal just like it was sent to stdout. But the <code>|</code> only redirects stdout (at
least in shells I've seen). So if you do the same <code>cat letter | sendemail</code> command, but the file <code>letter</code>
doesn't exist, cat won't send the error message to <code>sendemail</code> and cause it to get sent it as an email. The error
message will still show up on your terminal. (It's still up to the person who wrote <code>sendemail</code> to make it not
react to this by sending an empty email, but at least this way you'll find out that something went wrong :))
</p>
<h2>Other forms of stream redirection</h2>
<p>
There's a lot of other useful stuff you can do by changing where a process's stdin, stdout, and stderr are coming from or
going to. For example, in most shells the <code>&gt;</code> character is like <code>|</code> except that it writes the output
to a file instead of to the stdin of another command. <code>dmidecode > output</code> would run <code>dmidecode</code> but
save its output to the file named <code>output</code> instead of printing it to the terminal. You can do this with any
command.
<!--</p><p><code>cat input > output</code> will read the file
<code>input</code> and write its contents to the file <code>output</code>, effectively copying the file. This would be
more interesting if you used it with a command like <code>echo</code> in place of <code>cat</code>, which sends its arguments
to stdout. So <code>echo hello > output</code> would create a file named <code>output</code> that would have the word 'hello'
in it, and you'd be doing it with one command without having to open a text editor. (I realize this is still an unimpressive
example. But you could do this with any program, saving its output to a file instead of printing it to the terminal.)-->
<!--Maybe use a note to give the example of tee-->
</p><p>
Another useful form of this is <b>command substitution</b>, which lets you use the stdout of a command as arguments to
another. Most shells do this with backquotes (`). For example, <code>stat `cat files`</code> will run <code>cat files</code>,
reading the text from the file named <code>files</code>, and then run <code>stat</code> on each file listed in there.
<!--, and then-->
<!--run <code>stat</code> on each file it finds. Hopefully you're starting to see just how insanely useful this stuff can get.-->
</p><p>
Shells do have ways of redirecting stderr, mixing it in with stdout or sending it to a different file, et cetera, but
I think you get the idea now. The rest of that stuff is just a matter of looking up the syntax for your shell.
</p>
<h2>Clarifications</h2>
<p>
There are some possible misunderstandings I should dispel before I end this.
</p>
<ul>
<li><p>
	Not every command uses the standard streams at all. In general, if it doesn't take interactive input, it's not
	using its stdin stream.
	</p><p>
	(Notably, <code>cat</code> <i>does</i> use its standard input - or at least it can. You may have noticed that if
	you run it without any filenames it waits for you to type input. Whatever you type will be echoed back line-by-line.
	Ctrl-D to get out of this.)
</p></li><li><p>
	Things like reading files and playing music are not done with the stdin, stdout or stderr streams. When a program
	reads a file it's not using its stdin; it's just calling a function that opens the file behind the scenes.
	Likewise, a command that plays music is doing it by accessing your sound card, not writing the audio to stdout.
	</p><p>
	The downside of programs not using the standard streams is that then the user can't easily change where they're going,
	which makes the command less flexible. But for something like playing music that wouldn't really be useful anyway
	because you don't want the raw audio data dumped on your terminal screen; and if a program used stdin to read its
	configuration file then you'd have to know where that file is and pipe it in to the command every time you wanted
	to use it.
</p></li><li><p>
	The definition of a "stream" (as I understand it) is that it can be read or written to gradually. A process's stdin
	doesn't have to all be available for the program to start running, whereas if the output of another command is part of
	its arguments, then that other command does have to complete first because a process has to have access to all of
	its arguments upfront. Streams allow us to run commands in parallel, whereas arguments are more convenient for things
	that are supposed to be treated as distinct items rather than a stream of data.
</p></li>
</ul>
